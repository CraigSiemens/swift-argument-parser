<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    
    <title>Manual Parsing and Testing| Documentation</title>
    
    <link rel="icon"       href="favicon.ico" />
    <link rel="mask-icon"  href="favicon.svg" color="#333333" />
    <link rel='stylesheet' href='css/site.css' />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.0.1/styles/default.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.0.1/highlight.min.js"></script>
  </head>
  <body>
    <div id="app">
      <div class="doc-topic">
        <nav role="navigation" class="nav documentation-nav">
  <div class="nav__wrapper">
    <div class="nav__background"></div>
    <div class="nav-content">
      <div class="nav-title">
        <span class="nav-title-link inactive">Documentation</span>
      </div>
      <div class="nav-menu">
        <div class="nav-menu-tray">
          <ul class="nav-menu-items hierarchy">
            
              <li class="nav-menu-item hierarchy-item">
                
                
                  <a href="index.html" class="item">ArgumentParser</a>
                
              </li>
            
              <li class="nav-menu-item hierarchy-item">
                
                  <span class="current item">Manual Parsing and Testing</span>
                
                
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</nav>

<main id="main" role="main" class="main">
  <div class="topictitle">
  <span class="eyebrow">Article</span>
  <h1 class="title">Manual Parsing and Testing</h1>
</div>

  <div class="container content-grid">
  <div class="description">
    <div class="abstract content">
      Provide your own array of command-line inputs and work with parsed results by calling alternatives to <code>main()</code>.
    </div>
  </div>
  
  <!-- The sidebar once we have one: <div class="summary"></div> -->
  
  <div class="primary-content">
    <div class='content'><h2 id='Overview'>Overview</h2><p>For most programs, calling the static <code>main()</code> method on the root command type is all that’s necessary. That single call parses the command-line arguments to find the correct command from your tree of nested subcommands, instantiates and validates the result, and executes the chosen command. For more control, however, you can perform each of those steps manually.</p><h2 id='Parsing-Arguments'>Parsing Arguments</h2><p>For simple Swift scripts, and for those who prefer a straight-down-the-left-edge-of-the-screen scripting style, you can define a single <code>ParsableArguments</code> type to parse explicitly from the command-line arguments.</p><p>Let’s implement the <code>Select</code> command discussed in <em>Providing Custom Validation</em>, but using a scripty style instead of the typical command. First, we define the options as a <code>ParsableArguments</code> type:</p><div data-syntax="swift" class="code-listing">
  <div class="container-general">
    <pre><code><span class="code-line-container"><span data-line-number="1" class="code-number" style="display: none;"></span><span class="code-line">struct SelectOptions: ParsableArguments {</span></span>
<span class="code-line-container"><span data-line-number="2" class="code-number" style="display: none;"></span><span class="code-line">    @Option var count: Int = 1</span></span>
<span class="code-line-container"><span data-line-number="3" class="code-number" style="display: none;"></span><span class="code-line">    @Argument var elements: [String] = []</span></span>
<span class="code-line-container"><span data-line-number="4" class="code-number" style="display: none;"></span><span class="code-line">}</span></span>
</code></pre>
  </div>
</div>
<p>The next step is to parse our options from the command-line input:</p><div data-syntax="swift" class="code-listing">
  <div class="container-general">
    <pre><code><span class="code-line-container"><span data-line-number="1" class="code-number" style="display: none;"></span><span class="code-line">let options = SelectOptions.parseOrExit()</span></span>
</code></pre>
  </div>
</div>
<p>The static <code>parseOrExit()</code> method either returns a fully initialized instance of the type, or exits with an error message and code. Alternatively, you can call the throwing <code>parse()</code> method if you’d like to catch any errors that arise during parsing.</p><p>We can perform validation on the inputs and exit the script if necessary:</p><div data-syntax="swift" class="code-listing">
  <div class="container-general">
    <pre><code><span class="code-line-container"><span data-line-number="1" class="code-number" style="display: none;"></span><span class="code-line">guard let options.elements.count &gt;= options.count else {</span></span>
<span class="code-line-container"><span data-line-number="2" class="code-number" style="display: none;"></span><span class="code-line">    let error = ValidationError(&quot;Please specify a &#39;count&#39; less than the number of elements.&quot;)</span></span>
<span class="code-line-container"><span data-line-number="3" class="code-number" style="display: none;"></span><span class="code-line">    SelectOptions.exit(withError: error)</span></span>
<span class="code-line-container"><span data-line-number="4" class="code-number" style="display: none;"></span><span class="code-line">}</span></span>
</code></pre>
  </div>
</div>
<p>As you would expect, the <code>exit(withError:)</code> method includes usage information when you pass it a <code>ValidationError</code>.</p><p>Finally, we print out the requested number of elements:</p><div data-syntax="swift" class="code-listing">
  <div class="container-general">
    <pre><code><span class="code-line-container"><span data-line-number="1" class="code-number" style="display: none;"></span><span class="code-line">let chosen = options.elements</span></span>
<span class="code-line-container"><span data-line-number="2" class="code-number" style="display: none;"></span><span class="code-line">    .shuffled()</span></span>
<span class="code-line-container"><span data-line-number="3" class="code-number" style="display: none;"></span><span class="code-line">    .prefix(options.count)</span></span>
<span class="code-line-container"><span data-line-number="4" class="code-number" style="display: none;"></span><span class="code-line">print(chosen.joined(separator: &quot;\n&quot;))</span></span>
</code></pre>
  </div>
</div>
<h2 id='Parsing-Commands'>Parsing Commands</h2><p>Manually parsing commands is a little more complex than parsing a simple <code>ParsableArguments</code> type. The result of parsing from a tree of subcommands may be of a different type than the root of the tree, so the static <code>parseAsRoot()</code> method returns a type-erased <code>ParsableCommand</code>.</p><p>Let’s see how this works by using the <code>Math</code> command and subcommands defined in <em>Commands and Subcommands</em>. This time, instead of calling <code>Math.main()</code>, we’ll call <code>Math.parseAsRoot()</code>, and switch over the result:</p><div data-syntax="swift" class="code-listing">
  <div class="container-general">
    <pre><code><span class="code-line-container"><span data-line-number="1" class="code-number" style="display: none;"></span><span class="code-line">do {</span></span>
<span class="code-line-container"><span data-line-number="2" class="code-number" style="display: none;"></span><span class="code-line">    var command = try Math.parseAsRoot()</span></span>
<span class="code-line-container"><span data-line-number="3" class="code-number" style="display: none;"></span><span class="code-line"></span></span>
<span class="code-line-container"><span data-line-number="4" class="code-number" style="display: none;"></span><span class="code-line">    switch command {</span></span>
<span class="code-line-container"><span data-line-number="5" class="code-number" style="display: none;"></span><span class="code-line">    case var command as Math.Add:</span></span>
<span class="code-line-container"><span data-line-number="6" class="code-number" style="display: none;"></span><span class="code-line">        print(&quot;You chose to add \(command.options.values.count) values.&quot;)</span></span>
<span class="code-line-container"><span data-line-number="7" class="code-number" style="display: none;"></span><span class="code-line">        command.run()</span></span>
<span class="code-line-container"><span data-line-number="8" class="code-number" style="display: none;"></span><span class="code-line">    default:</span></span>
<span class="code-line-container"><span data-line-number="9" class="code-number" style="display: none;"></span><span class="code-line">        print(&quot;You chose to do something else.&quot;)</span></span>
<span class="code-line-container"><span data-line-number="10" class="code-number" style="display: none;"></span><span class="code-line">        try command.run()</span></span>
<span class="code-line-container"><span data-line-number="11" class="code-number" style="display: none;"></span><span class="code-line">    }</span></span>
<span class="code-line-container"><span data-line-number="12" class="code-number" style="display: none;"></span><span class="code-line">} catch {</span></span>
<span class="code-line-container"><span data-line-number="13" class="code-number" style="display: none;"></span><span class="code-line">    Math.exit(withError: error)</span></span>
<span class="code-line-container"><span data-line-number="14" class="code-number" style="display: none;"></span><span class="code-line">}</span></span>
</code></pre>
  </div>
</div>
<p>Our new logic intercepts the command between validation and running, and outputs an additional message:</p><div data-syntax="" class="code-listing">
  <div class="container-general">
    <pre><code><span class="code-line-container"><span data-line-number="1" class="code-number" style="display: none;"></span><span class="code-line">% math 10 15 7</span></span>
<span class="code-line-container"><span data-line-number="2" class="code-number" style="display: none;"></span><span class="code-line">You chose to add 3 values.</span></span>
<span class="code-line-container"><span data-line-number="3" class="code-number" style="display: none;"></span><span class="code-line">32</span></span>
<span class="code-line-container"><span data-line-number="4" class="code-number" style="display: none;"></span><span class="code-line">% math multiply 10 15 7</span></span>
<span class="code-line-container"><span data-line-number="5" class="code-number" style="display: none;"></span><span class="code-line">You chose to do something else.</span></span>
<span class="code-line-container"><span data-line-number="6" class="code-number" style="display: none;"></span><span class="code-line">1050</span></span>
</code></pre>
  </div>
</div>
<h2 id='Providing-Command-Line-Input'>Providing Command-Line Input</h2><p>All of the parsing methods — <code>parse()</code>, <code>parseOrExit()</code>, and <code>parseAsRoot()</code> — can optionally take an array of command-line inputs as an argument. You can use this capability to test your commands, to perform pre-parse filtering of the command-line arguments, or to manually execute commands from within the same or another target.</p><p>Let’s update our <code>select</code> script above to strip out any words that contain all capital letters before parsing the inputs.</p><div data-syntax="swift" class="code-listing">
  <div class="container-general">
    <pre><code><span class="code-line-container"><span data-line-number="1" class="code-number" style="display: none;"></span><span class="code-line">let noShoutingArguments = CommandLine.arguments.dropFirst().filter { phrase in</span></span>
<span class="code-line-container"><span data-line-number="2" class="code-number" style="display: none;"></span><span class="code-line">    phrase.uppercased() != phrase</span></span>
<span class="code-line-container"><span data-line-number="3" class="code-number" style="display: none;"></span><span class="code-line">}</span></span>
<span class="code-line-container"><span data-line-number="4" class="code-number" style="display: none;"></span><span class="code-line">let options = SelectOptions.parseOrExit(noShoutingArguments)</span></span>
</code></pre>
  </div>
</div>
<p>Now when we call our command, the parser won’t even see the capitalized words — <code>HEY</code> won’t ever be printed:</p><div data-syntax="" class="code-listing">
  <div class="container-general">
    <pre><code><span class="code-line-container"><span data-line-number="1" class="code-number" style="display: none;"></span><span class="code-line">% select hi howdy HEY --count 2</span></span>
<span class="code-line-container"><span data-line-number="2" class="code-number" style="display: none;"></span><span class="code-line">hi</span></span>
<span class="code-line-container"><span data-line-number="3" class="code-number" style="display: none;"></span><span class="code-line">howdy</span></span>
<span class="code-line-container"><span data-line-number="4" class="code-number" style="display: none;"></span><span class="code-line">% select hi howdy HEY --count 2</span></span>
<span class="code-line-container"><span data-line-number="5" class="code-number" style="display: none;"></span><span class="code-line">howdy</span></span>
<span class="code-line-container"><span data-line-number="6" class="code-number" style="display: none;"></span><span class="code-line">hi</span></span>
</code></pre>
  </div>
</div>
</div>
  </div>
</div>

  
  
  
</main>

      </div>
    </div>
    <footer class="footer"></footer>
    <script>hljs.highlightAll();</script>
  </body>
</html>
